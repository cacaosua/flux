"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var lodash=require("lodash"),jsoncParser=require("jsonc-parser"),createOrderedObject=require("@stoplight/ordered-object-literal"),createOrderedObject__default=_interopDefault(createOrderedObject),types=require("@stoplight/types"),fastStringify=_interopDefault(require("safe-stable-stringify"));const hasRef=e=>lodash.isObject(e)&&"$ref"in e&&"string"==typeof e.$ref,isLocalRef=e=>e.length>0&&"#"===e[0],replaceInString=(e,r,t)=>{const n=e.toString();let o="",i=n,a=0,s=i.indexOf(r);for(;s>-1;)o+=n.substring(a,a+s)+t,i=i.substring(s+r.length,i.length),a+=s+r.length,s=i.indexOf(r);return i.length>0&&(o+=n.substring(n.length-i.length,n.length)),o},encodePointerFragment=e=>"number"==typeof e?e:replaceInString(replaceInString(e,"~","~0"),"/","~1"),pathToPointer=e=>encodeUriFragmentIdentifier(e),encodeUriFragmentIdentifier=e=>{if(e&&"object"!=typeof e)throw new TypeError("Invalid type: path must be an array of segments.");return 0===e.length?"#":`#/${e.map(encodePointerFragment).join("/")}`},decodePointer=e=>replaceInString(replaceInString(decodeURIComponent(""+e),"~1","/"),"~0","~"),pointerToPath=e=>decodeUriFragmentIdentifier(e),decodeFragmentSegments=e=>{const r=e.length,t=[];let n=-1;for(;++n<r;)t.push(decodePointer(e[n]));return t},decodeUriFragmentIdentifier=e=>{if("string"!=typeof e)throw new TypeError("Invalid type: JSON Pointers are represented as strings.");if(0===e.length||"#"!==e[0])throw new URIError("Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.");if(1===e.length)return[];if("/"!==e[1])throw new URIError("Invalid JSON Pointer syntax.");return decodeFragmentSegments(e.substring(2).split("/"))},extractSourceFromRef=e=>{if("string"!=typeof e||0===e.length||isLocalRef(e))return null;const r=e.indexOf("#");return-1===r?e:e.slice(0,r)};function isObject(e){return"object"==typeof e&&null!==e}function _resolveInlineRef(e,r,t){if(null!==extractSourceFromRef(r))throw new ReferenceError("Cannot resolve external references");const n=pointerToPath(r);let o=e;for(const i of n){if(!(isObject(o)&&i in o))throw new ReferenceError(`Could not resolve '${r}'`);if(isObject(o=o[i])&&"$ref"in o){if(t.includes(o))return t[t.length-1];if(t.push(o),"string"!=typeof o.$ref)throw new TypeError("$ref should be a string");o=_resolveInlineRef(e,o.$ref,t)}}return o}function resolveInlineRef(e,r){return _resolveInlineRef(e,r,[])}const traverse=(e,r,t=[])=>{if(e&&"object"==typeof e)for(const n in e)e.hasOwnProperty(n)&&(r({parent:e,parentPath:t,property:n,propertyValue:e[n]}),e[n]&&"object"==typeof e[n]&&traverse(e[n],r,t.concat(n)))},BUNDLE_ROOT="#/__bundled__",ERRORS_ROOT="#/__errors__",bundleTarget=({document:e,path:r,bundleRoot:t=BUNDLE_ROOT,errorsRoot:n=ERRORS_ROOT},o)=>{if(r===t||r===n)throw new Error("Roots do not make any sense");return bundle(lodash.cloneDeep(e),pointerToPath(t),pointerToPath(n))(r,{[r]:!0},o)},bundle=(e,r,t)=>{const n=new Set,o=(i,a,s,c={},l={},f={})=>{const p=pointerToPath(i),u=lodash.get(e,p);traverse(s||u,({parent:t})=>{if(hasRef(t)&&isLocalRef(t.$ref)){const s=t.$ref;if(f[s])return;if(c[s])return void(t.$ref=c[s]);let p,u,d,h,g;try{let t;if(p=pointerToPath(s),Array.isArray(lodash.get(e,p.slice(0,-1)))){t=`${p[p.length-2]}_${p[p.length-1]}`}else t=p[p.length-1];d=t;let o=1;for(;n.has(d);)if(d=`${t}_${++o}`,o>20)throw new Error(`Keys ${t}_2 through ${t}_20 already taken.`);n.add(d),u=[...r,d],h=pathToPointer(u)}catch(e){f[s]=e.message}if(!p||!u||!h)return;if("object"==typeof e&&null!==e)try{g=resolveInlineRef(Object(e),s)}catch(r){g=lodash.get(e,p)}if(void 0!==g&&(c[s]=h,t.$ref=h,!lodash.has(l,u))){const r=lodash.get(e,p);Array.isArray(r)?lodash.set(l,u,new Array(r.length).fill(null)):"object"==typeof r&&lodash.set(l,u,{}),lodash.set(l,u,g),a[s]||(a[s]=!0,o(i,a,g,c,l,f),a[s]=!1)}}});const d=lodash.get(l,r);return d&&Object.keys(d).length&&lodash.set(u,r,d),(Object.keys(f).length||lodash.has(e,t))&&lodash.set(u,t,lodash.has(e,t)?lodash.get(e,t):f),u};return o},decodePointerFragment=e=>replaceInString(replaceInString(e,"~1","/"),"~0","~"),encodePointer=e=>replaceInString(replaceInString(e,"~","~0"),"//","/~1"),extractPointerFromRef=e=>{if("string"!=typeof e||0===e.length)return null;const r=e.indexOf("#");return-1===r?null:e.slice(r)},getFirstPrimitiveProperty=e=>{const r=jsoncParser.createScanner(e,!0);if(r.scan(),1!==r.getToken())return;if(r.scan(),2===r.getToken())return;if(10!==r.getToken())throw new SyntaxError("Unexpected character");const t=r.getTokenValue();if(r.scan(),6!==r.getToken())throw new SyntaxError("Colon expected");switch(r.scan(),r.getToken()){case 10:return[t,r.getTokenValue()];case 11:return[t,Number(r.getTokenValue())];case 8:return[t,!0];case 9:return[t,!1];case 7:return[t,null];case 16:throw new SyntaxError("Unexpected character");case 17:throw new SyntaxError("Unexpected end of file");default:return}},getJsonPathForPosition=({lineMap:e,ast:r},t)=>{const n=e[t.line],o=e[t.line+1];if(void 0===n)return;const i=jsoncParser.findNodeAtOffset(r,void 0===o?n+t.character:Math.min(o,n+t.character),!0);if(void 0===i)return;const a=jsoncParser.getNodePath(i);return 0!==a.length?a:void 0};function getLastPathSegment(e){return decodePointerFragment(e.split("/").pop()||"")}const getLocationForJsonPath=({lineMap:e,ast:r},t,n=!1)=>{const o=findNodeAtPath(r,t,n);if(void 0!==o&&void 0!==o.range)return{range:o.range}};function findNodeAtPath(e,r,t){e:for(const n of r){const r=Number.isInteger(Number(n))?Number(n):n;if("string"==typeof r||"number"==typeof r&&"array"!==e.type){if("object"!==e.type||!Array.isArray(e.children))return t?e:void 0;for(const t of e.children)if(Array.isArray(t.children)&&t.children[0].value===String(r)&&2===t.children.length){e=t.children[1];continue e}return t?e:void 0}if("array"!==e.type||r<0||!Array.isArray(e.children)||r>=e.children.length)return t?e:void 0;e=e.children[r]}return e}const parseWithPointers=(e,r={disallowComments:!0})=>{const t=[],{ast:n,data:o,lineMap:i}=parseTree(e,t,r);return{data:o,diagnostics:t,ast:n,lineMap:i}};function parseTree(e,r=[],t){const n=computeLineMap(e);let o={type:"array",offset:-1,length:-1,children:[],parent:void 0},i=null,a=[];const s=new WeakMap,c=[];function l(e){"property"===o.type&&(o.length=e-o.offset,o=o.parent)}function f(e,r,t){return{start:{line:e,character:r},end:{line:e,character:r+t}}}function p(e){return o.children.push(e),e}function u(e){Array.isArray(a)?a.push(e):null!==i&&(a[i]=e)}function d(e){u(e),c.push(a),a=e,i=null}function h(){a=c.pop()}const g={onObjectBegin:(e,r,n,i)=>{o=p({type:"object",offset:e,length:-1,parent:o,children:[],range:f(n,i,r)}),!1===t.ignoreDuplicateKeys&&s.set(o,[]),d(createObjectLiteral(!0===t.preserveKeyOrder))},onObjectProperty:(e,n,c,l,u)=>{if((o=p({type:"property",offset:n,length:-1,parent:o,children:[]})).children.push({type:"string",value:e,offset:n,length:c,parent:o}),!1===t.ignoreDuplicateKeys){const t=s.get(o.parent);t&&(0!==t.length&&t.includes(e)?r.push({range:f(l,u,c),message:"DuplicateKey",severity:types.DiagnosticSeverity.Error,path:getJsonPath(o),code:20}):t.push(e))}!0===t.preserveKeyOrder&&swapKey(a,e),i=e},onObjectEnd:(e,r,n,i)=>{!1===t.ignoreDuplicateKeys&&s.delete(o),o.length=e+r-o.offset,o.range&&(o.range.end.line=n,o.range.end.character=i+r),o=o.parent,l(e+r),h()},onArrayBegin:(e,r,t,n)=>{o=p({type:"array",offset:e,length:-1,parent:o,children:[],range:f(t,n,r)}),d([])},onArrayEnd:(e,r,t,n)=>{o.length=e+r-o.offset,o.range&&(o.range.end.line=t,o.range.end.character=n+r),o=o.parent,l(e+r),h()},onLiteralValue:(e,r,t,n,i)=>{p({type:getLiteralNodeType(e),offset:r,length:t,parent:o,value:e,range:f(n,i,t)}),l(r+t),u(e)},onSeparator:(e,r,t)=>{"property"===o.type&&(":"===e?o.colonOffset=r:","===e&&l(r))},onError:(e,t,n,o,i)=>{r.push({range:f(o,i,n),message:jsoncParser.printParseErrorCode(e),severity:types.DiagnosticSeverity.Error,code:e})}};jsoncParser.visit(e,g,t);const y=o.children[0];return y&&delete y.parent,{ast:y,data:a[0],lineMap:n}}function getLiteralNodeType(e){switch(typeof e){case"boolean":return"boolean";case"number":return"number";case"string":return"string";default:return"null"}}const computeLineMap=e=>{const r=[0];let t=0;for(;t<e.length;t++)"\n"===e[t]&&r.push(t+1);return r.push(t+1),r};function getJsonPath(e,r=[]){return"property"===e.type&&r.unshift(e.children[0].value),void 0!==e.parent?("array"===e.parent.type&&void 0!==e.parent.parent&&r.unshift(e.parent.children.indexOf(e)),getJsonPath(e.parent,r)):r}function createObjectLiteral(e){return e?createOrderedObject__default({}):{}}function swapKey(e,r){if(!(r in e))return;const t=createOrderedObject.getOrder(e),n=t.indexOf(r);-1!==n&&(t.splice(n,1),t.push(r))}const renameObjectKey=(e,r,t)=>{if(!e||!Object.hasOwnProperty.call(e,r)||r===t)return e;const n={};for(const[o,i]of Object.entries(e))o===r?n[t]=i:o in n||(n[o]=i);return n},safeParse=(e,r)=>{if("string"!=typeof e)return e;try{const t=parseNumber(e);return"string"==typeof t?t:JSON.parse(e,r)}catch(e){return}},parseNumber=e=>{const r=Number(e);return Number.isFinite(r)?String(r)===e?r:e:NaN},safeStringify=(e,r,t)=>{if("string"==typeof e)return e;try{return JSON.stringify(e,r,t)}catch(n){return fastStringify(e,r,t)}},startsWith=(e,r)=>{if(e instanceof Array){if(r instanceof Array){if(r.length>e.length)return!1;for(const t in r){if(!r.hasOwnProperty(t))continue;const n=parseInt(e[t]),o=parseInt(r[t]);if(isNaN(n)&&isNaN(o)){if(e[t]!==r[t])return!1}else if(n!==o)return!1}}}else{if("string"!=typeof e)return!1;if("string"==typeof r)return e.startsWith(r)}return!0},stringify=(e,r,t)=>{const n=safeStringify(e,r,t);if(void 0===n)throw new Error("The value could not be stringified");return n};function toPropertyPath(e){return e.replace(/^(\/|#\/)/,"").split("/").map(decodePointerFragment).map(sanitize).join(".")}function sanitize(e){return e.includes(".")?`["${e.replace(/"/g,'\\"')}"]`:e}const KEYS=Symbol.for(createOrderedObject.ORDER_KEY_ID),traps={ownKeys:e=>KEYS in e?e[KEYS]:Reflect.ownKeys(e)},trapAccess=e=>new Proxy(e,traps);function trimStart(e,r){if("string"==typeof e&&"string"==typeof r)return lodash.trimStart(e,r);if(!(e&&Array.isArray(e)&&e.length&&r&&Array.isArray(r)&&r.length))return e;let t=0;for(const n in e)if(e.hasOwnProperty(n)){if(e[n]!==r[n])break;t++}return e.slice(t)}exports.BUNDLE_ROOT=BUNDLE_ROOT,exports.ERRORS_ROOT=ERRORS_ROOT,exports.KEYS=KEYS,exports.bundleTarget=bundleTarget,exports.decodePointer=decodePointer,exports.decodePointerFragment=decodePointerFragment,exports.encodePointer=encodePointer,exports.encodePointerFragment=encodePointerFragment,exports.extractPointerFromRef=extractPointerFromRef,exports.extractSourceFromRef=extractSourceFromRef,exports.getFirstPrimitiveProperty=getFirstPrimitiveProperty,exports.getJsonPathForPosition=getJsonPathForPosition,exports.getLastPathSegment=getLastPathSegment,exports.getLocationForJsonPath=getLocationForJsonPath,exports.hasRef=hasRef,exports.isLocalRef=isLocalRef,exports.parseTree=parseTree,exports.parseWithPointers=parseWithPointers,exports.pathToPointer=pathToPointer,exports.pointerToPath=pointerToPath,exports.renameObjectKey=renameObjectKey,exports.resolveInlineRef=resolveInlineRef,exports.safeParse=safeParse,exports.safeStringify=safeStringify,exports.startsWith=startsWith,exports.stringify=stringify,exports.toPropertyPath=toPropertyPath,exports.trapAccess=trapAccess,exports.traverse=traverse,exports.trimStart=trimStart;
