"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeRules = void 0;
const severity_1 = require("../severity");
const validation_1 = require("../validation");
function mergeRules(target, source, rulesetSeverity) {
    for (const [name, rule] of Object.entries(source)) {
        if (rulesetSeverity !== void 0) {
            if (validation_1.isValidRule(rule) && !('enabled' in rule)) {
                let enabled;
                if (rulesetSeverity === 'all') {
                    enabled = true;
                }
                else if (rulesetSeverity === 'off') {
                    enabled = false;
                }
                else {
                    enabled = rule.recommended !== false;
                }
                rule.enabled = enabled;
            }
            processRule(target, name, rule);
        }
        else {
            processRule(target, name, rule);
        }
    }
    return target;
}
exports.mergeRules = mergeRules;
function processRule(rules, name, rule) {
    const existingRule = rules[name];
    switch (typeof rule) {
        case 'boolean':
            if (validation_1.isValidRule(existingRule)) {
                existingRule.enabled = rule;
            }
            break;
        case 'string':
        case 'number':
            if (validation_1.isValidRule(existingRule)) {
                if (rule === 'off') {
                    existingRule.enabled = false;
                }
                else {
                    existingRule.severity = severity_1.getDiagnosticSeverity(rule);
                    existingRule.enabled = true;
                }
            }
            break;
        case 'object':
            if (Array.isArray(rule)) {
                processRule(rules, name, rule[0]);
                if (validation_1.isValidRule(existingRule) && rule.length === 2 && rule[1] !== void 0) {
                    if ('functionOptions' in existingRule.then) {
                        existingRule.then.functionOptions = rule[1];
                    }
                }
            }
            else if (validation_1.isValidRule(existingRule)) {
                Object.assign(existingRule, normalizeRule(rule));
            }
            else {
                rules[name] = normalizeRule(rule);
            }
            break;
        default:
            throw new Error('Invalid value for a rule');
    }
}
function normalizeRule(rule) {
    return Object.assign(Object.defineProperties({}, Object.getOwnPropertyDescriptors(rule)), {
        recommended: rule.recommended !== false,
        severity: rule.severity === void 0 ? severity_1.DEFAULT_SEVERITY_LEVEL : severity_1.getDiagnosticSeverity(rule.severity),
    });
}
//# sourceMappingURL=rules.js.map